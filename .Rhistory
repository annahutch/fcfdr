points(qqplot(-log10(p[not]), -log10(m$value[which(m$group==3)]),plot.it = F), pch = 16, col = "blue")
points(qqplot(-log10(p[not]), -log10(m$value[which(m$group==4)]),plot.it = F), pch = 16, col = "green")
qqplot(-log10(p[not]), -log10(p[-not]), ylab = "SNPs in peak", xlab = "SNPs not in peak", pch = 16, main = "QQ plot for (-log10) p-vals")
abline(0,1)
str(qs_logFC)
# how many are non-zero
lapply(qs_logFC, function(x) length(which(x!=0)))
4/16
5/16
7/16
2/23
21/23
getwd
pkgdown::build_site()
devtools::document()
devtools::load_all()
devtools::check()
library(devtools)
devtools::document()
devtools::load_all()
devtools::load_all()
devtools::document()
devtools::document()
devtools::load_all()
devtools::check()
devtools::check()
devtools::build()
devtools::document()
pkgdown::build_site()
install.packages(c('Rcpp', 'rstan'), dependencies = TRUE, type = 'source')
install.packages(c("Rcpp", "rstan"), dependencies = TRUE, type = "source")
devtools::install_github("andrewGhazi/malacoda", build_vignettes = TRUE)
library (malacoda)
qqnorm
qqnorm)_
qqnorm()
set.seed(1)
n = 50000
n1p = 500 # associated variants
zp = c(rnorm(n1p, sd=5), rnorm(n-n1p, sd=1)) # z-scores
p = 2*pnorm(-abs(zp)) # convert to p-values
hist(p)
mixture_comp1 <- function(x) rnorm(x, mean = -0.5, sd = 0.5)
mixture_comp2 <- function(x) rnorm(x, mean = 2, sd = 1)
n = length(p)
z = runif(n)
q <- c(mixture_comp1(n1p), mixture_comp2(n-n1p))
hist(q)
indep_index = seq(1, n, 1)
nxbin = 1000; res_p = 300; res_q = 500; gridp = 50; splinecorr = TRUE; dist_thr = 0.5; plot_KDE = FALSE
plot_KDE = TRUE
if( sign(cor(p[indep_index], q[indep_index], method="spearman"))!= sign(cor(p, q, method="spearman")) ) stop('Correlation between p and q in whole dataset has a different sign to that in independent subset of SNPs')
# ensure low q enriched for low p
if(cor(p[indep_index], q[indep_index], method="spearman") < 0) q <- -q
zp = -qnorm(p/2) # convert p-vals to z-scores
# define support for KDE (range of data +/- 10%)
q_10 <- (max(q) - min(q)) * 0.1
zp_10 <- (max(zp) - min(zp)) * 0.1
lims <- c(0, max(zp) + zp_10, min(q) - q_10, max(q) + q_10) # c(xl, xu, yl, yu)
# folded normal KDE only computed for independent SNPs (so BW computation isnt biased)
p_ind <- p[indep_index]
zp_ind <- zp[indep_index]
q_ind <- q[indep_index]
# bivariate density of zp and q
kpq <- MASS::kde2d(c(zp_ind, -zp_ind), c(q_ind, q_ind), n = c(res_p, res_q), lims = lims)
# find optimal mlests parameter values
N = length(c(zp_ind, -zp_ind)); b = 4.3 * exp(-0.26 * log(N, 10)); med = median(c(zp_ind, -zp_ind))
sc = diff(quantile(c(zp_ind, -zp_ind))[c(2,4)])/(2*qnorm(.75))
mlests = locfdr:::locmle(c(zp_ind, -zp_ind), xlim=c(med, b*sc))
names(mlests) = NULL
# local FDR = P(H0|ZP=zp)
lfdr <- locfdr(c(zp_ind, -zp_ind), bre = c(kpq$x[-length(kpq$x)] + diff(kpq$x)/2, kpq$x[length(kpq$x)] + diff(kpq$x)[length(diff(kpq$x))]/2, -c(kpq$x[-length(kpq$x)] + diff(kpq$x)/2, kpq$x[length(kpq$x)] + diff(kpq$x)[length(diff(kpq$x))]/2)), mlests = c(mlests[1], b*mlests[2]), plot = 0, df = 10)
# extract lfdr values for kpq$x values
lfdr_vals <- lfdr$mat[res_p:length(lfdr$mat[,1]),][,2]
library(locfdr)
# local FDR = P(H0|ZP=zp)
lfdr <- locfdr(c(zp_ind, -zp_ind), bre = c(kpq$x[-length(kpq$x)] + diff(kpq$x)/2, kpq$x[length(kpq$x)] + diff(kpq$x)[length(diff(kpq$x))]/2, -c(kpq$x[-length(kpq$x)] + diff(kpq$x)/2, kpq$x[length(kpq$x)] + diff(kpq$x)[length(diff(kpq$x))]/2)), mlests = c(mlests[1], b*mlests[2]), plot = 0, df = 10)
# extract lfdr values for kpq$x values
lfdr_vals <- lfdr$mat[res_p:length(lfdr$mat[,1]),][,2]
lfdrmat <- matrix(lfdr_vals,nrow(kpq$z),ncol(kpq$z))
Pr.pqh0 <- lfdrmat * kpq$z # prob(p,q,H0)
Pr.q.h0 <-  colSums(Pr.pqh0)/sum(Pr.pqh0) # prob(q|H0) = prob(q,H0)/prob(H0)
Pr.cq.h0 <- cumsum(Pr.q.h0) # prob (Q<q | H0)
int_kqh0 <- t(outer(Pr.cq.h0, rep(1, res_p)))
int_kqh0 <- int_kqh0/max(int_kqh0)
plot(kpq$y,Pr.q.h0)
density(q)
plot(density(q))
points(density(q), col = "red")
lines(density(q), col = "red")
plot(density(q))
lines(density(q), col = "red")
dim(kpq$z)
plot(c(q_ind, q_ind), kpq$z[,res_q])
plot(kpq$y, kpq$z[,res_q])
plot(kpq$y, kpq$z[,res_p])
length(kpq$y)
plot(kpq$y, kpq$z[res_p,])
plot(kpq$y, kpq$z[res_q,])
plot(kpq$y, kpq$z[1,])
plot(kpq$y, kpq$z[1,])
lines(density(q[ind])
)
lines(density(q_ind))
?density
density(q_ind)
plot(density(q_ind))
plot(kpq$y, kpq$z[1,]/max(kpq$z[1,]))
lines(density(q_ind))
plot(kpq$y, int_kpq[1,], )
cell_size <- (diff(range(lims[1], lims[2])) / res_p) * (diff(range(lims[3], lims[4])) / res_q)
integ <- sum(kpq$z) * cell_size
kpq_norm <- kpq$z/integ
int_kpq <- t(apply(apply(kpq_norm[res_p:1,], 2, cumsum), 1, cumsum))[res_p:1, ]
int_kpq <- int_kpq/max(int_kpq)
# kgrid estimates P(P<=p, Q<=q)/P(Q<=q|H0)
kgrid <- kpq
kgrid$z <- exp(log(int_kpq)-log(int_kqh0))
# avoid 0-0 errors
kgrid$z[which(kgrid$z==0)] <- min(kgrid$z[which(kgrid$z>0)])
plot(kpq$y, int_kpq[1,])
integ
plot(kpq$y, int_kpq[,1])
plot(kpq$y, kpq_norm[1,])
plot(kpq$y, kpq_norm[1,])
lines(density(q_ind), col = "red")
plot(kpq$y, kpq_norm[1,]/max(kpq_norm[1,]))
lines(density(q_ind)/max(density(q_ind)), col = "red")
hist(q_ind)
lines(kpq$y, kpq_norm[1,])
hist(q_ind, freq = FALSE)
lines(kpq$y, kpq_norm[1,])
hist(q_ind, freq = FALSE, xlab = "q", main = "Histogram of q with\nestimated density in red")
lines(kpq$y, kpq_norm[1,], col =  "red")
#' @import fields
#' @import stats
#' @import polyCub
#' @import hexbin
#' @import bigsplines
#' @import grDevices
#'
#'
#' @return list of length two: (1) dataframe of p-values, q-values and v-values (2) dataframe of auxiliary data (q_low used for left censoring, how many data-points were left censored and/or spline corrected)
#' @export
flexible_cfdr <- function(p, q, indep_index, nxbin = 1000, res_p = 300, res_q = 500, gridp = 50, splinecorr = TRUE, dist_thr = 0.5, plot_KDE = FALSE){
if( sign(cor(p[indep_index], q[indep_index], method="spearman"))!= sign(cor(p, q, method="spearman")) ) stop('Correlation between p and q in whole dataset has a different sign to that in independent subset of SNPs')
# ensure low q enriched for low p
if(cor(p[indep_index], q[indep_index], method="spearman") < 0) q <- -q
zp = -qnorm(p/2) # convert p-vals to z-scores
# define support for KDE (range of data +/- 10%)
q_10 <- (max(q) - min(q)) * 0.1
zp_10 <- (max(zp) - min(zp)) * 0.1
lims <- c(0, max(zp) + zp_10, min(q) - q_10, max(q) + q_10) # c(xl, xu, yl, yu)
# folded normal KDE only computed for independent SNPs (so BW computation isnt biased)
p_ind <- p[indep_index]
zp_ind <- zp[indep_index]
q_ind <- q[indep_index]
# bivariate density of zp and q
kpq <- MASS::kde2d(c(zp_ind, -zp_ind), c(q_ind, q_ind), n = c(res_p, res_q), lims = lims)
### estimate P(Q<=q|H0)
# find optimal mlests parameter values
N = length(c(zp_ind, -zp_ind)); b = 4.3 * exp(-0.26 * log(N, 10)); med = median(c(zp_ind, -zp_ind))
sc = diff(quantile(c(zp_ind, -zp_ind))[c(2,4)])/(2*qnorm(.75))
mlests = locfdr:::locmle(c(zp_ind, -zp_ind), xlim=c(med, b*sc))
names(mlests) = NULL
# local FDR = P(H0|ZP=zp)
lfdr <- locfdr(c(zp_ind, -zp_ind), bre = c(kpq$x[-length(kpq$x)] + diff(kpq$x)/2, kpq$x[length(kpq$x)] + diff(kpq$x)[length(diff(kpq$x))]/2, -c(kpq$x[-length(kpq$x)] + diff(kpq$x)/2, kpq$x[length(kpq$x)] + diff(kpq$x)[length(diff(kpq$x))]/2)), mlests = c(mlests[1], b*mlests[2]), plot = 0, df = 10)
# extract lfdr values for kpq$x values
lfdr_vals <- lfdr$mat[res_p:length(lfdr$mat[,1]),][,2]
lfdrmat <- matrix(lfdr_vals,nrow(kpq$z),ncol(kpq$z))
Pr.pqh0 <- lfdrmat * kpq$z # prob(p,q,H0)
Pr.q.h0 <-  colSums(Pr.pqh0)/sum(Pr.pqh0) # prob(q|H0) = prob(q,H0)/prob(H0)
Pr.cq.h0 <- cumsum(Pr.q.h0) # prob (Q<q | H0)
int_kqh0 <- t(outer(Pr.cq.h0, rep(1, res_p)))
int_kqh0 <- int_kqh0/max(int_kqh0)
### estimate P(P<=p, Q<=q)
cell_size <- (diff(range(lims[1], lims[2])) / res_p) * (diff(range(lims[3], lims[4])) / res_q)
integ <- sum(kpq$z) * cell_size
kpq_norm <- kpq$z/integ
int_kpq <- t(apply(apply(kpq_norm[res_p:1,], 2, cumsum), 1, cumsum))[res_p:1, ]
int_kpq <- int_kpq/max(int_kpq)
# kgrid estimates P(P<=p, Q<=q)/P(Q<=q|H0)
kgrid <- kpq
kgrid$z <- exp(log(int_kpq)-log(int_kqh0))
# avoid 0-0 errors
kgrid$z[which(kgrid$z==0)] <- min(kgrid$z[which(kgrid$z>0)])
if(plot_KDE == TRUE){
hist(q_ind, freq = FALSE, xlab = "q", main = "Histogram of q with\nestimated density in red")
lines(kpq$y, kpq_norm[1,], col =  "red")
}
# cgrid is grid of cFDR values
# estimated by p/kgrid
cgrid <- vector(mode = "list", length = 3)
cgrid$x = c(seq(0, 0.05, length.out = 101)[1:100], seq(0.05, lims[2], length.out = res_p))
cgrid$y = seq(lims[3], lims[4], length.out = res_q)
ptest = 2*pnorm(-cgrid$x)
cfdrs <- matrix(rep(0, length(cgrid$y)*length(cgrid$x)), ncol = length(cgrid$y))
for (i in 1:length(cgrid$y)) {
xdenom=interp.surface(kgrid,cbind(cgrid$x, rep(cgrid$y[i], length(cgrid$x))))
cfdrs[,i]=cummin(ptest/xdenom)
}
cgrid$z <- cfdrs
# left-censoring
q_grid <- seq(lims[3], lims[4], length.out = res_q)
groups <- cut(q_ind, breaks = q_grid, include.lowest = TRUE, right = TRUE)
# use left point of region where the number of points used for estimation in that bin is >gridp
q_low <- q_grid[which(table(groups)>gridp)[1]]
q_cens <- q
q_cens[which(q_cens < q_low)] <- q_low
# bivariate binning
binned_res <- hexbin(zp, q_cens, xbins = nxbin, IDs = TRUE)
bins <- cbind(binned_res@xcm, binned_res@ycm)
ccut <- interp.surface(cgrid, bins) # cFDR values for binned data
# L-curves are contours of cFDR curves
cl <- lapply(ccut, function(l) grDevices::contourLines(x=cgrid, levels=l))
cl_basic <- cl
# rearrage L-curves so they are defined anticlockwise
lengths <- lapply(cl, length)
for(i in which(lengths>1)){
first = lapply(cl[[i]], function(x) x$y[1]) %>% unlist()
cl[[i]] = cl[[i]][order(first)]
}
# remove contour coords in problematic low q regions
for(i in which(lengths>1)){
cl[[i]][[1]] <- NULL
}
# define newx and newy as joined segments
for(i in 1:length(cl)){
cl[[i]]$newx <- c()
for(j in 1:length(cl[[i]])){
cl[[i]]$newx <- c(cl[[i]]$newx, cl[[i]][[j]]$x)
cl[[i]]$newy <- c(cl[[i]]$newy, cl[[i]][[j]]$y)
}
}
Lx <- lapply(cl, function(x) 2*pnorm(-abs(x$newx)))
Ly <- lapply(cl, function(x) x$newy)
### estimate P(P=p,Q=q|H0)=P(P=q|H0)*P(Q=q|H0)
fph0 = function(x) dunif(x) # P|H0
fqh0 <- approxfun(kpq$y, Pr.q.h0) # Q|H0
fpqh0 <- function(s){
fph0(s[,1])*fqh0(s[,2])
}
# normalise so integral is 1 over full region
fullint <- polyCub(owin(poly=list(x = c(1, 0, 0, 1), y = c(lims[4], lims[4], lims[3], lims[3])), check = FALSE, fix = FALSE), fpqh0, method = "midpoint")
fpqh0 <- function(s){
fph0(s[,1])*fqh0(s[,2])/fullint
}
# integrate bivariate null over L region to get v-vals
v_tmp <- mapply(function(X, Y){
polyCub(owin(poly=list(x = c(X[length(X)], 0,0, c(X[1],X)), y = c(lims[4], lims[4], lims[3], c(lims[3],Y))), check = FALSE, fix  = FALSE), fpqh0, method = "midpoint")
}, X = Lx, Y = Ly)
# map back binned data to original data points
v <- v_tmp[match(binned_res@cID, binned_res@cell)]
v_b4spline <- v
v[which(v==0)] <- 1e-100 # replace any 0 v-vals
if(splinecorr == TRUE){ # spline correction
spline_fit <- bigspline(x = q, y = log10(v/p), nknots = 5, rparm = NA)
#pred_out <- predict.bigspline(spline_fit, newdata = seq(min(q), max(q), 0.05))
distances <- abs(log10(v/p)-spline_fit$fitted.values)
corrected_ind <- which(abs(log10(v/p)-spline_fit$fitted.values) > dist_thr)
v[corrected_ind] <- pmin(10^spline_fit$fitted[corrected_ind]*p[corrected_ind], 1)
}
v[which(v>1)] <- 1 # fix bug where some v vals = 1 + 2.220446e-16
df <- data.frame(p, q, v)
return(list(df, data.frame(q_low = q_low, left_cens = length(which(q < q_low)), splinecorr = length(corrected_ind))))
}
res <- flexible_cfdr(p, q, indep_index = seq(1, n, 1), plot_KDE = T)
library(fcfdr)
plot(1)
res <- flexible_cfdr(p, q, indep_index = seq(1, n, 1), plot_KDE = TRUE)
res <- flexible_cfdr(p, q, indep_index = seq(1, n, 1), plot_KDE = FALSE)
devtools::document()
rm(list = c("flexible_cfdr", "lims", "n"))
devtools::document()
devtools::check()
devtools::document()
install.packages("spatstat.geomo")
install.packages("spatstat.geom")
library(spatstat.geom)
devtools::document()
devtools::build()
devtools::document()
devtools::load_all()
set.seed(1)
library(fcfdr)
n = 50000
n1p = 500 # associated variants
zp = c(rnorm(n1p, sd=5), rnorm(n-n1p, sd=1)) # z-scores
p = 2*pnorm(-abs(zp)) # convert to p-values
hist(p)
mixture_comp1 <- function(x) rnorm(x, mean = -0.5, sd = 0.5)
mixture_comp2 <- function(x) rnorm(x, mean = 2, sd = 1)
n = length(p)
z = runif(n)
q <- c(mixture_comp1(n1p), mixture_comp2(n-n1p))
hist(q)
corr_plot(p, q)
stratified_qqplot(data_frame = data.frame(p, q), "p", "q", thresholds = c(quantiles(q), probs = c(0.25, 0.5, 0.75, 1)))
stratified_qqplot(data_frame = data.frame(p, q), "p", "q", thresholds = c(quantile(q), probs = c(0.25, 0.5, 0.75, 1)))
data.frame(p, q)
c(quantile(q), probs = c(0.25, 0.5, 0.75, 1))
stratified_qqplot(data_frame = data.frame(p, q), "p", "q", thresholds = c(quantile(q), prob = c(0.25, 0.5, 0.75, 1)))
quantile(q), prob = c(0.25, 0.5, 0.75, 1))
quantile(q, probs = c(0.25, 0.5, 0.75, 1)))
quantile(q, probs = c(0.25, 0.5, 0.75, 1))
stratified_qqplot(data_frame = data.frame(p, q), "p", "q", thresholds = c(quantile(q, probs = c(0.25, 0.5, 0.75, 1))))
stratified_qqplot(data_frame = data.frame(p, q), "p", "q", thresholds = c(round(quantile(q, probs = c(0.25, 0.5, 0.75, 1)), 3)))
devtools::check()
devtools::document()
devtools::load_all()
devtools::document()
devtools::load_all()
devtools::ddoc
devtools::document()
pkgdown::build_site()
install.packages("pkgdown")
library(pkgdown)
pkgdown::build_site()
pkgdown::build_site(new_process = FALSE, document = FALSE)
devtools::document()
devtools::document()
devtools::document()
devtools::check()
devtools::check()
devtools::document()
Sys.setenv(`_R_S3_METHOD_REGISTRATION_NOTE_OVERWRITES_` = "false")
devtools::document()
devtools::check()
devtools::document()
devtools::check()
pkgdown::build_site()
set.seed(1)
library(fcfdr)
data(T1D_df, package = "fcfdr")
head(T1D_df)
orig_p <- T1D_df$p
chr <- T1D_df$chrom
q1 <- T1D_df$RA_p
q2 <- T1D_df$DGF_ENCODE
q3 <- log(T1D_df$Th_H3K27ac+1)
hist(q2 )
ind_snps <- which(T1D_df$ldak_weight != 0)
v
iter1_res <- flexible_cfdr(p = orig_p,
q = q1,
indep_index = ind_snps)
v1 <- iter1_res[[1]]$v
iter2_res <- binary_cfdr(p = v1,
q = q2,
chr = chr)
v2 <- iter2_res$v
head(v2)
head(v1)
head(v1)
head(q2)
table(q2)
head(chr)
table(chr)
p_res <- split(p, f = chr)
length(chr)
length(p)
length(v1)
p_res <- split(v1, f = chr)
p_res
x <- unsplit(p_res, f = chr)
head(x)
head(v1)
2352/513000 * 100
(2352/513000) * 100
14014/401248
14014/401248 * 100
head(p)
head(orig_p)
head(v1)
iter2_res
str(iter2_res)
p = v1;q = q2
unique_chr <- unique(chr)
unique_chr
# split p and q into chromosomes
p_res <- split(p, f = chr)
q_res <- split(q, f = chr)
minp=min(p)
maxp=max(p)
# prepare container for v
v_res <- vector(mode = "list", length = length(unique_chr))
## prepare x for approxfun
logx=seq(log10(minp),log10(maxp),length.out=1000)
x=c(exp(logx),1)
chrom <- unique_chr[j]
j = 1
chrom <- unique_chr[j]
chrom
p_loo <- p[-which(chr == chrom)] # df leave-one-chromosome-out
q_loo <- q[-which(chr == chrom)] # df leave-one-chromosome-out
ps <- p_res[[j]]
qs <- q_res[[j]]
q0 <- sum(q_loo == 1 & p_loo > 0.5)/sum(p_loo > 0.5)
mult <- (sum(q_loo == 0 & p_loo > 1/2)/sum(q_loo == 1 & p_loo > 1/2))
q0_sol=sapply(ps, function(p) max(sum(p_loo <= p & q_loo==0),1))
q1_sol=sapply(ps, function(p) max(sum(p_loo <= p & q_loo==1),1))
sol <- ifelse(qs==0,
mult*ps / q0_sol,
(1/mult)*ps / q1_sol)
q0 <- sum(q_loo == 1 & p_loo > 0.5)/sum(p_loo > 0.5)
mult <- (sum(q_loo == 0 & p_loo > 1/2)/sum(q_loo == 1 & p_loo > 1/2))
q0_sol=sapply(ps, function(p) max(sum(p_loo <= p & q_loo==0),1))
q1_sol=sapply(ps, function(p) max(sum(p_loo <= p & q_loo==1),1))
sol <- ifelse(qs==0,
mult*ps / q0_sol,
(1/mult)*ps / q1_sol)
## approx g0
y=x/sapply(x, function(p) max(sum(p_loo <= p & q_loo==0),1))
extr=Hmisc::approxExtrap(y,x,xout=unique(sol))
invg0=approxfun(x=extr$x,y=pmax(pmin(extr$y,1),0),rule=2)
## invg0_spline=splinefun(x=y,y=x,method="hyman")
## approx g1
y1=x/sapply(x, function(p) max(sum(p_loo <= p & q_loo==1),1))
extr1=Hmisc::approxExtrap(y1,x,xout=unique(sol))
invg1=approxfun(x=extr1$x,y=pmax(pmin(extr1$y,1),0),rule=2)
p1=ifelse(qs==0,invg1(sol),ps)
p0=ifelse(qs==1,invg0(sol),ps)
v_res[[j]] <- p0*(1-q0) + p1*q0
v_res[[1]]
head(v_res[[j]])
head(res)
pkgdown::build_site()
devtools::document()
pkgdown::build_site()
devtools::document()
set.seed(1)
library(fcfdr)
data(T1D_df, package = "fcfdr")
head(T1D_df)
binary_cfdr
orig_p <- T1D_df$p
chr <- T1D_df$chrom
q1 <- T1D_df$RA_p
q2 <- T1D_df$DGF_ENCODE
q3 <- log(T1D_df$Th_H3K27ac+1)
ind_snps <- which(T1D_df$ldak_weight != 0)
iter1_res <- flexible_cfdr(p = orig_p,
q = q1,
indep_index = ind_snps)
v1 <- iter1_res[[1]]$v
#'
#' @param p p values for principal trait (vector of length n)
#' @param q binary auxillary data values (vector of length n)
#' @param chr chromosome each SNP resides (vector of length n)
#'
#' @importFrom Hmisc approxExtrap
#'
#' @return dataframe of p, q and v values
#' @export
#'
binary_cfdr <- function(p, q, chr){
unique_chr <- unique(chr)
# split p and q into chromosomes
p_res <- split(p, f = chr)
q_res <- split(q, f = chr)
minp=min(p)
maxp=max(p)
# prepare container for v
v_res <- vector(mode = "list", length = length(unique_chr))
## prepare x for approxfun
logx=seq(log10(minp),log10(maxp),length.out=1000)
x=c(exp(logx),1)
for(j in 1:length(unique_chr)){
chrom <- unique_chr[j]
p_loo <- p[-which(chr == chrom)] # df leave-one-chromosome-out
q_loo <- q[-which(chr == chrom)] # df leave-one-chromosome-out
ps <- p_res[[j]]
qs <- q_res[[j]]
q0 <- sum(q_loo == 1 & p_loo > 0.5)/sum(p_loo > 0.5)
mult <- (sum(q_loo == 0 & p_loo > 1/2)/sum(q_loo == 1 & p_loo > 1/2))
q0_sol=sapply(ps, function(p) max(sum(p_loo <= p & q_loo==0),1))
q1_sol=sapply(ps, function(p) max(sum(p_loo <= p & q_loo==1),1))
sol <- ifelse(qs==0,
mult*ps / q0_sol,
(1/mult)*ps / q1_sol)
## approx g0
y=x/sapply(x, function(p) max(sum(p_loo <= p & q_loo==0),1))
extr=Hmisc::approxExtrap(y,x,xout=unique(sol))
invg0=approxfun(x=extr$x,y=pmax(pmin(extr$y,1),0),rule=2)
## invg0_spline=splinefun(x=y,y=x,method="hyman")
## approx g1
y1=x/sapply(x, function(p) max(sum(p_loo <= p & q_loo==1),1))
extr1=Hmisc::approxExtrap(y1,x,xout=unique(sol))
invg1=approxfun(x=extr1$x,y=pmax(pmin(extr1$y,1),0),rule=2)
p1=ifelse(qs==0,invg1(sol),ps)
p0=ifelse(qs==1,invg0(sol),ps)
v_res[[j]] <- p0*(1-q0) + p1*q0
}
data.frame(p = unsplit(p_res, f = chr), q = unsplit(q_res, f = chr), v = unsplit(v_res, f = chr))
}
iter2_res <- binary_cfdr(p = v1,
q = q2,
chr = chr)
v2 <- iter2_res$v
res <- data.frame(orig_p, q1 = iter1_res[[1]]$q, q2 = as.factor(iter2_res$q), q3 = iter3_res[[1]]$q, v1, v2)
res <- data.frame(orig_p, q1 = iter1_res[[1]]$q, q2 = as.factor(iter2_res$q), v1, v2
mid1 <- median(res$q1)
ggplot(res, aes(x = orig_p, y = v1, col = q1)) + geom_point(cex = 0.5) + theme_cowplot(12) + background_grid(major = "xy", minor = "none") + geom_abline(intercept = 0, slope = 1,  linetype="dashed") + xlab("P") + ylab("V1") + ggtitle(paste0("Iteration 1")) + scale_color_gradient2(midpoint = mid1, low = "blue", mid = "white", high = "red", space = "Lab")
res <- data.frame(orig_p, q1 = iter1_res[[1]]$q, q2 = as.factor(iter2_res$q), v1, v2)
library(ggplot2)
library(cowplot)
mid1 <- median(res$q1)
ggplot(res, aes(x = orig_p, y = v1, col = q1)) + geom_point(cex = 0.5) + theme_cowplot(12) + background_grid(major = "xy", minor = "none") + geom_abline(intercept = 0, slope = 1,  linetype="dashed") + xlab("P") + ylab("V1") + ggtitle(paste0("Iteration 1")) + scale_color_gradient2(midpoint = mid1, low = "blue", mid = "white", high = "red", space = "Lab")
ggplot(res, aes(x = v1, y = v2, col = q2)) + geom_point(cex = 0.5) + theme_cowplot(12) + background_grid(major = "xy", minor = "none") + geom_abline(intercept = 0, slope = 1,  linetype="dashed") + xlab("V1") + ylab("V2") + ggtitle(paste0("Iteration 2"))
ggplot(res, aes(x = v1, y = v2, col = q2)) + geom_point(cex = 0.5) + theme_cowplot(12) + background_grid(major = "xy", minor = "none") + geom_abline(intercept = 0, slope = 1,  linetype="dashed") + xlab("V1") + ylab("V2") + ggtitle(paste0("Iteration 2"))++ scale_x_log10() + scale_y_log10()
ggplot(res, aes(x = v1, y = v2, col = q2)) + geom_point(cex = 0.5) + theme_cowplot(12) + background_grid(major = "xy", minor = "none") + geom_abline(intercept = 0, slope = 1,  linetype="dashed") + xlab("V1") + ylab("V2") + ggtitle(paste0("Iteration 2"))+ scale_x_log10() + scale_y_log10()
pkgdown::build_site()
