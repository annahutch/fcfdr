v[corrected_ind] <- pmin(10^spline_fit$fitted[corrected_ind]*p[corrected_ind], 1)
}
v[which(v>1)] <- 1 # fix bug where some v vals = 1 + 2.220446e-16
# print warning if v-values have changed too much as something has likely gone wrong
if( median(v) < 0.8*median(p) | median(v) > 1.2*median(p) ){
warning('v-values very different to input p-values - check results (if q has a long tail then try left censoring)')
}
df <- data.frame(p, q, v)
if(splinecorr == TRUE){
return(list(df, data.frame(q_low = q_low, left_cens = length(which(q < q_low)), splinecorr = length(corrected_ind))))
} else
return(list(df, data.frame(q_low = q_low, left_cens = length(which(q < q_low)), splinecorr = NA)))
}
#' @title Function to downsample independent SNPs to match MAF distribution of whole set.
#'
#' @description Matches MAF distribution of independent set of SNPs to MAF distribution of whole set of SNPs to avoid MAF-based confounding.
#'
#' @details Must supply maf values from the whole data set, not just the independent SNPs.
#'
#' @param maf minor allele frequencies of (all) SNPs
#' @param indep_index indices of independent SNPs
#'
#' @return indices of independent SNP in chosen in sample
match_ind_maf <- function(maf, indep_index) {
breaks <- seq(0, 0.5, length=51)
daf <- data.frame(indep_index = indep_index, maf = maf[indep_index])
maf_interval <- as.character(cut(maf, breaks = breaks, include.lowest = T))
daf$maf_interval <- maf_interval[indep_index]
maf_interval_freq.whole <- table(maf_interval)
maf_interval_freq.ind <- table(daf$maf_interval)
maf_interval_freq.whole.relative <- maf_interval_freq.whole/sum(maf_interval_freq.whole)
maf_interval_freq.ind.relative <- maf_interval_freq.ind/sum(maf_interval_freq.ind)
max_sample_size <- floor(min(maf_interval_freq.ind/maf_interval_freq.whole.relative))
scaled_interval_sample_sizes <- floor(maf_interval_freq.whole.relative*max_sample_size)
indep_sample_index <- unlist(lapply(names(scaled_interval_sample_sizes), function(x) sample(subset(daf, maf_interval==x)$indep_index, size=scaled_interval_sample_sizes[x])))
indep_sample_index
}
#' @param p p values for principal trait (vector of length n)
#' @param q continuous auxiliary data values (vector of length n)
#' @param indep_index indices of independent SNPs
#' @param maf minor allele frequencies for SNPs to which \code{p} and \code{q} relate (optional and used to perform MAF matching)
#' @param check_indep_cor check that sign of the correlation between \code{p} and \code{q} is the same in the independent subset as in the whole
#' @param enforce_p_q_cor if \code{p} and \code{q} are negatively correlated, flip the sign on \code{q} values
#'
#' @return list of values used as input into \code{locfdr::locfdr} function intrinsically in \code{flexible_cfdr}
#' @export
#'
parameters_in_locfdr <- function(p, q, indep_index, res_p = 300, res_q = 500, maf = NULL, check_indep_cor = TRUE, enforce_p_q_cor = TRUE){
# match MAF distribution of independent SNPs to that of whole
if(!is.null(maf)) {
if(length(maf) != length(p)) {
stop("Mismatch in lengths of p and maf vectors")
}
indep_index <- match_ind_maf(maf, indep_index)
}
# Suitable for auxiliary covariates other than p-values
if(check_indep_cor) {
if(sign(cor(p[indep_index], q[indep_index], method="spearman"))!= sign(cor(p, q, method="spearman"))) {
stop('Correlation between p and q in whole dataset has a different sign to that in independent subset of SNPs')
}
}
# ensure low q enriched for low p
if(enforce_p_q_cor) {
if(cor(p[indep_index], q[indep_index], method="spearman") < 0) {
q <- -q
}
}
zp = -qnorm(p/2) # convert p-vals to z-scores
# define support for KDE (range of data +/- 10%)
q_10 <- (max(q) - min(q)) * 0.1
zp_10 <- (max(zp) - min(zp)) * 0.1
lims <- c(0, max(zp) + zp_10, min(q) - q_10, max(q) + q_10) # c(xl, xu, yl, yu)
# folded normal KDE only computed for independent SNPs (so BW computation isnt biased)
p_ind <- p[indep_index]
zp_ind <- zp[indep_index]
q_ind <- q[indep_index]
# bivariate density of zp and q
kpq <- MASS::kde2d(c(zp_ind, -zp_ind), c(q_ind, q_ind), n = c(res_p, res_q), lims = lims)
### estimate P(Q<=q|H0)
# find optimal mlests parameter values
N = length(c(zp_ind, -zp_ind)); b = 4.3 * exp(-0.26 * log(N, 10)); med = median(c(zp_ind, -zp_ind))
sc = diff(quantile(c(zp_ind, -zp_ind))[c(2,4)])/(2*qnorm(.75))
mlests = locfdr:::locmle(c(zp_ind, -zp_ind), xlim=c(med, b*sc))
names(mlests) = NULL
return(list("zz" = c(zp_ind, -zp_ind), "bre" = c(kpq$x[-length(kpq$x)] + diff(kpq$x)/2, kpq$x[length(kpq$x)] + diff(kpq$x)[length(diff(kpq$x))]/2, -c(kpq$x[-length(kpq$x)] + diff(kpq$x)/2, kpq$x[length(kpq$x)] + diff(kpq$x)[length(diff(kpq$x))]/2)), "mlests" = c(mlests[1], b*mlests[2])))
}
iter1_res <- flexible_cfdr(p = orig_p,
q = q1,
indep_index = ind_snps,
maf = MAF)
iter1_res <- flexible_cfdr(p = orig_p,
q = q1,
indep_index = ind_snps,
maf = MAF, suppress_locfdrwarning = TRUE)
v1 <- iter1_res[[1]]$v
iter2_res <- binary_cfdr(p = v1,
q = q2,
group = chr)
v2 <- iter2_res$v
iter3_res <- flexible_cfdr(p = v2,
q = q3,
indep_index = ind_snps,
maf = MAF)
v
v3 <- iter3_res[[1]]$v
res <- data.frame(orig_p, q1 = iter1_res[[1]]$q, q2 = as.factor(iter2_res$q), q3 = iter3_res[[1]]$q, v1, v2, v3)
head(res)
library(ggplot2)
library(cowplot)
mid1 <- median(res$q1)
ggplot(res, aes(x = orig_p, y = v1, col = q1)) + geom_point(cex = 0.5) + theme_cowplot(12) + background_grid(major = "xy", minor = "none") + geom_abline(intercept = 0, slope = 1,  linetype="dashed") + xlab("P") + ylab("V1") + ggtitle(paste0("Iteration 1")) + scale_color_gradient2(midpoint = mid1, low = "blue", mid = "white", high = "red", space = "Lab")
ggplot(res, aes(x = v1, y = v2, col = q2)) + geom_point(cex = 0.5) + theme_cowplot(12) + background_grid(major = "xy", minor = "none") + geom_abline(intercept = 0, slope = 1,  linetype="dashed") + xlab("V1") + ylab("V2") + ggtitle(paste0("Iteration 2"))
mid3 <- median(res$q3)
ggplot(res, aes(x = v2, y = v3, col = q3)) + geom_point(cex = 0.5) + theme_cowplot(12) + background_grid(major = "xy", minor = "none") + geom_abline(intercept = 0, slope = 1,  linetype="dashed") + xlab("V2") + ylab("V3") + ggtitle(paste0("Iteration 3")) + scale_color_gradient2(midpoint = mid3, low = "blue", mid = "white", high = "red", space = "Lab")
mid1 <- median(res$q1)
ggplot(res, aes(x = orig_p, y = v3)) + geom_point(cex = 0.5, alpha = 0.5) + theme_cowplot(12) + background_grid(major = "xy", minor = "none") + geom_abline(intercept = 0, slope = 1,  linetype="dashed", col = "red") + xlab("P") + ylab("V3") + ggtitle(paste0("V3 against original p-values"))
ggplot(res, aes(x = -log10(orig_p), y = -log10(v3))) + geom_point(cex = 0.5, alpha = 0.5) + theme_cowplot(12) + background_grid(major = "xy", minor = "none") + geom_abline(intercept = 0, slope = 1,  linetype="dashed", col = "red") + xlab("P (-log10)") + ylab("V3 (-log10)") + ggtitle(paste0("V3 against original p-values (-log10)")) + coord_cartesian(ylim = c(0,10), xlim = c(0,10))
fdr_thr <- 5*10^-6
p_fdr <- p.adjust(orig_p, method = "BH")
v3_fdr <- p.adjust(v3, method = "BH")
length(which(v3_fdr <= fdr_thr & p_fdr > fdr_thr))
median(T1D_df$RA_p[which(v3_fdr < fdr_thr & p_fdr > fdr_thr)])
median(T1D_df$RA_p)
mean(T1D_df$DGF_ENCODE[which(v3_fdr < fdr_thr & p_fdr > fdr_thr)])
mean(T1D_df$DGF_ENCODE)
median(T1D_df$Th_H3K27ac[which(v3_fdr < fdr_thr & p_fdr > fdr_thr)])
median(T1D_df$Th_H3K27ac)
head(T1D_df)
x <- cbind(T1D_df, res)
x
heaD(x)
head(x)
saveRDS(x, "T1Dapp_res.RDS")
devtools::install_github("annahutch/fcfdr")
devtools::document()
rm(list = c("flexible_cfdr", "match_ind_maf", "parameters_in_locfdr"))
devtools::install_github("annahutch/fcfdr")
pkgdown::build_site()
devtools::document()
pkgdown::build_site()
devtools::install_github("annahutch/fcfdr")
library(fcfdr)
flexible_cfdr()
flexible_cfdr
devtools::install_github("annahutch/fcfdr")
library(fcfdr)
devtools::install_github("annahutch/fcfdr")
library(fcfdr)
devtools::install_github("annahutch/fcfdr")
library(fcfdr)
devtools::install_github("annahutch/fcfdr")
library(fcfdr)
flexible_cfdr
devtools::install_github("annahutch/fcfdr", force = TRUE)
library(fcfdr)
flexible_cfdr
#' @importFrom spatstat.geom owin
#' @importFrom fields interp.surface
#' @importFrom polyCub polyCub
#' @importFrom hexbin hexbin
#' @importFrom bigsplines bigspline
#' @importFrom grDevices contourLines
#' @import stats
#'
#' @return List of length two: (1) data.frame of p-values, q-values and v-values (2) data.frame of auxiliary data (q_low used for left censoring, how many data-points were left censored and/or spline corrected)
#' @export
flexible_cfdr <- function(p, q, indep_index, res_p = 300, res_q = 500, nxbin = 1000, gridp = 50, splinecorr = TRUE, dist_thr = 0.5, locfdr_df = 10, plot = TRUE, maf = NULL, check_indep_cor = TRUE, enforce_p_q_cor = TRUE){
# match MAF distribution of independent SNPs to that of whole
if(!is.null(maf)) {
if(length(maf) != length(p)) {
stop("Mismatch in lengths of p and maf vectors")
}
indep_index <- match_ind_maf(maf, indep_index)
}
# Suitable for auxiliary covariates other than p-values
if(check_indep_cor) {
if(sign(cor(p[indep_index], q[indep_index], method="spearman"))!= sign(cor(p, q, method="spearman"))) {
stop('Correlation between p and q in whole dataset has a different sign to that in independent subset of SNPs')
}
}
# ensure low q enriched for low p
if(enforce_p_q_cor) {
if(cor(p[indep_index], q[indep_index], method="spearman") < 0) {
q <- -q
}
}
zp = -qnorm(p/2) # convert p-vals to z-scores
# define support for KDE (range of data +/- 10%)
q_10 <- (max(q) - min(q)) * 0.1
zp_10 <- (max(zp) - min(zp)) * 0.1
lims <- c(0, max(zp) + zp_10, min(q) - q_10, max(q) + q_10) # c(xl, xu, yl, yu)
# folded normal KDE only computed for independent SNPs (so BW computation isnt biased)
p_ind <- p[indep_index]
zp_ind <- zp[indep_index]
q_ind <- q[indep_index]
# bivariate density of zp and q
kpq <- MASS::kde2d(c(zp_ind, -zp_ind), c(q_ind, q_ind), n = c(res_p, res_q), lims = lims)
### estimate P(Q<=q|H0)
# find optimal mlests parameter values
N = length(c(zp_ind, -zp_ind)); b = 4.3 * exp(-0.26 * log(N, 10)); med = median(c(zp_ind, -zp_ind))
sc = diff(quantile(c(zp_ind, -zp_ind))[c(2,4)])/(2*qnorm(.75))
mlests = locfdr:::locmle(c(zp_ind, -zp_ind), xlim=c(med, b*sc))
names(mlests) = NULL
# local FDR = P(H0|ZP=zp)
lfdr <- tryCatch(
{
locfdr(c(zp_ind, -zp_ind), bre = c(kpq$x[-length(kpq$x)] + diff(kpq$x)/2, kpq$x[length(kpq$x)] + diff(kpq$x)[length(diff(kpq$x))]/2, -c(kpq$x[-length(kpq$x)] + diff(kpq$x)/2, kpq$x[length(kpq$x)] + diff(kpq$x)[length(diff(kpq$x))]/2)), mlests = c(mlests[1], b*mlests[2]), plot = 0, df = locfdr_df)
},
warning=function(cond) {
message("Warning from locfdr:")
message(cond)
message("Examine the fit to the data")
message("See locfdr documentation here: https://cran.r-project.org/web/packages/locfdr/vignettes/locfdr-example.pdf")
message("...")
message("Alternatively, the fcfdr::parameters_in_locfdr function can be used to output the parameters used as input in locfdr::locfdr")
locfdr(c(zp_ind, -zp_ind), bre = c(kpq$x[-length(kpq$x)] + diff(kpq$x)/2, kpq$x[length(kpq$x)] + diff(kpq$x)[length(diff(kpq$x))]/2, -c(kpq$x[-length(kpq$x)] + diff(kpq$x)/2, kpq$x[length(kpq$x)] + diff(kpq$x)[length(diff(kpq$x))]/2)), mlests = c(mlests[1], b*mlests[2]), plot = 0, df = locfdr_df)
}
)
# extract lfdr values for kpq$x values
lfdr_vals <- lfdr$mat[res_p:length(lfdr$mat[,1]),][,2]
lfdrmat <- matrix(lfdr_vals,nrow(kpq$z),ncol(kpq$z))
Pr.pqh0 <- lfdrmat * kpq$z # prob(p,q,H0)
Pr.q.h0 <-  colSums(Pr.pqh0)/sum(Pr.pqh0) # prob(q|H0) = prob(q,H0)/prob(H0)
Pr.cq.h0 <- cumsum(Pr.q.h0) # prob (Q<q | H0)
int_kqh0 <- t(outer(Pr.cq.h0, rep(1, res_p)))
int_kqh0 <- int_kqh0/max(int_kqh0)
### estimate P(P<=p, Q<=q)
cell_size <- (diff(range(lims[1], lims[2])) / res_p) * (diff(range(lims[3], lims[4])) / res_q)
integ <- sum(kpq$z) * cell_size
kpq_norm <- kpq$z/integ
int_kpq <- t(apply(apply(kpq_norm[res_p:1,], 2, cumsum), 1, cumsum))[res_p:1, ]
int_kpq <- int_kpq/max(int_kpq)
# kgrid estimates P(P<=p, Q<=q)/P(Q<=q|H0)
kgrid <- kpq
kgrid$z <- exp(log(int_kpq)-log(int_kqh0))
# avoid 0-0 errors
kgrid$z[which(kgrid$z==0)] <- min(kgrid$z[which(kgrid$z>0)])
if(plot == TRUE){
hist(q_ind, freq = FALSE, xlab = "q", main = "Histogram of q with\nestimated density in red")
lines(kpq$y, kpq_norm[1,], col =  "red")
image(kpq, xlab = "Principal trait Z-scores", ylab = "q", main = "Estimated density from 2D KDE")
}
# cgrid is grid of cFDR values
# estimated by p/kgrid
cgrid <- vector(mode = "list", length = 3)
cgrid$x = c(seq(0, 0.05, length.out = 101)[1:100], seq(0.05, lims[2], length.out = res_p))
cgrid$y = seq(lims[3], lims[4], length.out = res_q)
ptest = 2*pnorm(-cgrid$x)
cfdrs <- matrix(rep(0, length(cgrid$y)*length(cgrid$x)), ncol = length(cgrid$y))
for (i in 1:length(cgrid$y)) {
xdenom=interp.surface(kgrid,cbind(cgrid$x, rep(cgrid$y[i], length(cgrid$x))))
cfdrs[,i]=cummin(ptest/xdenom)
}
cgrid$z <- cfdrs
# left-censoring
q_grid <- seq(lims[3], lims[4], length.out = res_q)
groups <- cut(q_ind, breaks = q_grid, include.lowest = TRUE, right = TRUE)
# use left point of region where the number of points used for estimation in that bin is >gridp
q_low <- q_grid[which(table(groups)>gridp)[1]]
q_cens <- q
q_cens[which(q_cens < q_low)] <- q_low
# bivariate binning
binned_res <- hexbin(zp, q_cens, xbins = nxbin, IDs = TRUE)
bins <- cbind(binned_res@xcm, binned_res@ycm)
ccut <- interp.surface(cgrid, bins) # cFDR values for binned data
# L-curves are contours of cFDR curves
cl <- lapply(ccut, function(l) grDevices::contourLines(x=cgrid, levels=l))
cl_basic <- cl
# rearrage L-curves so they are defined anticlockwise
lengths <- lapply(cl, length)
for(i in which(lengths>1)){
first = unlist(lapply(cl[[i]], function(x) x$y[1]))
cl[[i]] = cl[[i]][order(first)]
}
# remove contour coords in problematic low q regions
for(i in which(lengths>1)){
cl[[i]][[1]] <- NULL
}
# define newx and newy as joined segments
for(i in 1:length(cl)){
cl[[i]]$newx <- c()
for(j in 1:length(cl[[i]])){
cl[[i]]$newx <- c(cl[[i]]$newx, cl[[i]][[j]]$x)
cl[[i]]$newy <- c(cl[[i]]$newy, cl[[i]][[j]]$y)
}
}
Lx <- lapply(cl, function(x) 2*pnorm(-abs(x$newx)))
Ly <- lapply(cl, function(x) x$newy)
### estimate P(P=p,Q=q|H0)=P(P=q|H0)*P(Q=q|H0)
fph0 = function(x) dunif(x) # P|H0
fqh0 <- approxfun(kpq$y, Pr.q.h0) # Q|H0
fpqh0 <- function(s){
fph0(s[,1])*fqh0(s[,2])
}
# normalise so integral is 1 over full region
fullint <- polyCub(owin(poly=list(x = c(1, 0, 0, 1), y = c(lims[4], lims[4], lims[3], lims[3])), check = FALSE, fix = FALSE), fpqh0, method = "midpoint")
fpqh0 <- function(s){
fph0(s[,1])*fqh0(s[,2])/fullint
}
# integrate bivariate null over L region to get v-vals
v_tmp <- mapply(function(X, Y){
polyCub(owin(poly=list(x = c(X[length(X)], 0,0, c(X[1],X)), y = c(lims[4], lims[4], lims[3], c(lims[3],Y))), check = FALSE, fix  = FALSE), fpqh0, method = "midpoint")
}, X = Lx, Y = Ly)
# map back binned data to original data points
v <- v_tmp[match(binned_res@cID, binned_res@cell)]
v_b4spline <- v
v[which(v==0)] <- 1e-100 # replace any 0 v-vals
if(splinecorr == TRUE){ # spline correction
spline_fit <- bigspline(x = q, y = log10(v/p), nknots = 5, rparm = NA)
#pred_out <- predict.bigspline(spline_fit, newdata = seq(min(q), max(q), 0.05))
distances <- abs(log10(v/p)-spline_fit$fitted.values)
corrected_ind <- which(abs(log10(v/p)-spline_fit$fitted.values) > dist_thr)
v[corrected_ind] <- pmin(10^spline_fit$fitted[corrected_ind]*p[corrected_ind], 1)
}
v[which(v>1)] <- 1 # fix bug where some v vals = 1 + 2.220446e-16
# print warning if v-values have changed too much as something has likely gone wrong
if( median(v) < 0.8*median(p) | median(v) > 1.2*median(p) ){
warning('v-values very different to input p-values - check results (if q has a long tail then try left censoring)')
}
df <- data.frame(p, q, v)
if(splinecorr == TRUE){
return(list(df, data.frame(q_low = q_low, left_cens = length(which(q < q_low)), splinecorr = length(corrected_ind))))
} else
return(list(df, data.frame(q_low = q_low, left_cens = length(which(q < q_low)), splinecorr = NA)))
}
iter1_res <- flexible_cfdr(p = orig_p,
q = q1,
indep_index = ind_snps,
maf = MAF)
devtools::document()
rm(list = c("flexible_cfdr"))`
rm(list = c("flexible_cfdr"))
devtools::document()
devtools::install_github("annahutch/fcfdr", force = TRUE)
library(fc)
library(fcfdr)
flexible_cfdr
devtools::document()
devtools::install_github("annahutch/fcfdr", force = TRUE)
library(fcfdr)
flexible_cfdr()
flexible_cfdr
library(fcfdr)
flexible_cfdr
install_github("annahutch/fcfdr@00b5d9587868ae43b9bf238cd550d12716d6730e")
remotes::install_github("annahutch/fcfdr@00b5d9587868ae43b9bf238cd550d12716d6730e")
set.seed(1)
library(fcfdr)
data(T1D_df, package = "fcfdr")
head(T1D_df)
orig_p <- T1D_df$p
chr <- T1D_df$chrom
MAF <- T1D_df$maf
q1 <- T1D_df$RA_p
q2 <- T1D_df$DGF_ENCODE
q3 <- log(T1D_df$Th_H3K27ac+1) # deal with long tail
ind_snps <- which(T1D_df$ldak_weight != 0)
iter1_res <- flexible_cfdr(p = orig_p,
q = q1,
indep_index = ind_snps,
maf = MAF)
devtools::install_github("annahutch/fcfdr")
pkgdown::build_site()
devtools::document()
devtools::check()
pkgdown::build_site()
set.seed(1)
library(fcfdr)
data(T1D_df, package = "fcfdr")
head(T1D_df)
```{r}
orig_p <- T1D_df$p
chr <- T1D_df$chrom
MAF <- T1D_df$maf
q1 <- T1D_df$RA_p
q2 <- T1D_df$DGF_ENCODE
q3 <- log(T1D_df$Th_H3K27ac+1) # deal with long tail
ind_snps <- which(T1D_df$ldak_weight != 0)
iter1_res <- flexible_cfdr(p = orig_p,
q = q1,
indep_index = ind_snps,
maf = MAF)
devtools::document()
devtools::install_github("annahutch/fcfdr")
f2 <- function() {
cat("before tryCatch\n")
withCallingHandlers({
withRestarts({
stop("this is an error!")
}, muffleStop=function() {
message("'stop' muffled")
})
},
error = function(cond) {
print(cond$message)
invokeRestart("muffleStop")
}
)
cat("after tryCatch\n")
}
f2
f2()
foo <- function(x) {
if (x == 1) {
warning('Warning')
} else if (x == 0) {
stop('Error')
}
return(1)
}
bar <- function(x){
tryCatch(
expr    = foo(x),
error   = identity,
warning = function(w) invokeRestart("muffleWarning")
)
}
foo(0)
foo(1)
bar <- function(x){
tryCatch(
expr    = foo(x),
error   = identity,
warning = function(w) invokeRestart("muffleWarning")
)
}
bar(0)
bar(1)
devtools::document()
devtools::install_github("annahutch/fcfdr")
devtools::document()
pkgdown::build_site
pkgdown::build_site()
devtools::document()
devtools::install_github("annahutch/fcfdr")
devtools::document()
devtools::install_github("annahutch/fcfdr")
message("Warning from locfdr:\nExamine the fit to the data")
message("Warning from locfdr\nExamine the fit to the data\nSee locfdr documentation here: https://cran.r-project.org/web/packages/locfdr/vignettes/locfdr-example.pdf\nAlternatively, the fcfdr::parameters_in_locfdr function can be used to output the parameters used as input in locfdr::locfdr")
message("Warning from locfdr\nExamine the fit to the data\nSee locfdr documentation here: https://cran.r-project.org/web/packages/locfdr/vignettes/locfdr-example.pdf\nAlternatively, the fcfdr::parameters_in_locfdr function can be used to output the parameters used as input in locfdr::locfdr\n...")
devtools::document()
pkgdown::build_site()
devtools::document()
devtools::document()
4. Average fold-enrichment ratio of H3K27ac ChIP-seq counts relative to expected background counts in T1D-relevant cell types. Fold-enrichment ratio were downloaded from NIH Roadmap for CD3, CD4+ CD25int CD127+ Tmem, CD4+ CD25+ CD127- Treg, CD4+ CD25- Th, CD4+ CD25- CD45RA+, CD4 memory, CD4 naive, CD8 memory and CD8 naive primary cell types (from https://egg2.wustl.edu/roadmap/data/byFileType/signal/consolidated/macs2signal/foldChange)
devtools::load_all()
set.seed(1)
library(fcfdr)
data(T1D_application_data, package = "fcfdr")
head(T1D_df)
head(T1D_application_data)
orig_p <- T1D_application_data$T1D_pval
chr <- T1D_application_data$CHR19
MAF <- T1D_application_data$MAF
q1 <- T1D_application_data$RA_pval
q2 <- T1D_application_data$DGF
q3 <- log(T1D_application_data$H3K27ac+1) # deal with long
ind_snps <- which(T1D_application_data$LDAK_weight != 0)
ind_snps
iter1_res <- flexible_cfdr(p = orig_p,
q = q1,
indep_index = ind_snps,
maf = MAF)
v1 <- iter1_res[[1]]$v
iter2_res <- binary_cfdr(p = v1,
q = q2,
group = chr)
v2 <- iter2_res$v
iter3_res <- flexible_cfdr(p = v2,
q = q3,
indep_index = ind_snps,
maf = MAF)
v
v3 <- iter3_res[[1]]$v
res <- data.frame(orig_p, q1 = iter1_res[[1]]$q, q2 = as.factor(iter2_res$q), q3 = iter3_res[[1]]$q, v1, v2, v3)
head(res)
```{r}
library(ggplot2)
library(cowplot)
mid1 <- median(res$q1)
ggplot(res, aes(x = orig_p, y = v1, col = q1)) + geom_point(cex = 0.5) + theme_cowplot(12) + background_grid(major = "xy", minor = "none") + geom_abline(intercept = 0, slope = 1,  linetype="dashed") + xlab("P") + ylab("V1") + ggtitle(paste0("Iteration 1")) + scale_color_gradient2(midpoint = mid1, low = "blue", mid = "white", high = "red", space = "Lab")
ggplot(res, aes(x = v1, y = v2, col = q2)) + geom_point(cex = 0.5) + theme_cowplot(12) + background_grid(major = "xy", minor = "none") + geom_abline(intercept = 0, slope = 1,  linetype="dashed") + xlab("V1") + ylab("V2") + ggtitle(paste0("Iteration 2"))
mid3 <- median(res$q3)
ggplot(res, aes(x = v2, y = v3, col = q3)) + geom_point(cex = 0.5) + theme_cowplot(12) + background_grid(major = "xy", minor = "none") + geom_abline(intercept = 0, slope = 1,  linetype="dashed") + xlab("V2") + ylab("V3") + ggtitle(paste0("Iteration 3")) + scale_color_gradient2(midpoint = mid3, low = "blue", mid = "white", high = "red", space = "Lab")
mid1 <- median(res$q1)
ggplot(res, aes(x = orig_p, y = v3)) + geom_point(cex = 0.5, alpha = 0.5) + theme_cowplot(12) + background_grid(major = "xy", minor = "none") + geom_abline(intercept = 0, slope = 1,  linetype="dashed", col = "red") + xlab("P") + ylab("V3") + ggtitle(paste0("V3 against original p-values"))
ggplot(res, aes(x = -log10(orig_p), y = -log10(v3))) + geom_point(cex = 0.5, alpha = 0.5) + theme_cowplot(12) + background_grid(major = "xy", minor = "none") + geom_abline(intercept = 0, slope = 1,  linetype="dashed", col = "red") + xlab("P (-log10)") + ylab("V3 (-log10)") + ggtitle(paste0("V3 against original p-values (-log10)")) + coord_cartesian(ylim = c(0,10), xlim = c(0,10))
fdr_thr <- 5*10^-6
p_fdr <- p.adjust(orig_p, method = "BH")
v3_fdr <- p.adjust(v3, method = "BH")
length(which(v3_fdr <= fdr_thr & p_fdr > fdr_thr))
median(T1D_df$RA_p[which(v3_fdr < fdr_thr & p_fdr > fdr_thr)])
median(T1D_df$RA_p)
median(T1D_application_data$RA_p[which(v3_fdr < fdr_thr & p_fdr > fdr_thr)])
median(T1D_application_data$RA_p)
mean(T1D_application_data$DGF_ENCODE[which(v3_fdr < fdr_thr & p_fdr > fdr_thr)])
mean(T1D_application_data$DGF_ENCODE)
mean(T1D_application_data$DGF[which(v3_fdr < fdr_thr & p_fdr > fdr_thr)])
mean(T1D_application_data$DGF)
median(T1D_application_data$H3K27ac[which(v3_fdr < fdr_thr & p_fdr > fdr_thr)])
median(T1D_application_data$H3K27ac)
devtools::document()
devtools::build_site()
install.packages("gitcreds")
library(gitcreds)
gitcreds_set()
gitcreds_set()
gitcreds_set()
p_fdr[which(orig_p <= 5*10^{-8})
]
max(p_fdr[which(orig_p <= 5*10^{-8})])
devtools::build_site()
