<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>LDAK vignette</title>

<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">LDAK vignette</h1>



<p>The <code>flexible_cfdr</code> function requires as input the indices of an independent subset of SNPs. These indices indicate the <code>(p,q)</code> pairs considered independent observations for the purpose of the KDE fitting procedure.</p>
<p>In practice, we identify independent SNPs as those assigned a non-zero weighting by the <a href="http://dougspeed.com/ldak/">LDAK packageâ€™s</a> weighting calculation <a href="http://dougspeed.com/calculate-weightings/">procedure</a>. These weightings were originally developed as a means of adjusting for the unequal tagging of (causal) SNPs across the genome when estimating heritability. The calculation procedure requires haplotype information, which we obtain in the form of the 1000 Genomes (1000G) Phase 3 data.</p>
<p>The purpose of this vignette is to sketch out our own approach to generating LDAK weightings for use in <code>fcfdr</code>. Whilst RMarkdown was used to generate this HTML document, the code snippets contained in this vignette are intended to serve as static illustrations and are not intended to be run without further modification.</p>
<p>This workflow was written with the use of LDAK <code>v5.1</code> (download <a href="http://dougspeed.com/downloads/">here</a>) and PLINK <code>v1.90b6.21 64-bit (19 Oct 2020)</code> (download <a href="https://www.cog-genomics.org/plink/2.0/">here</a>). We also use code from the R packages <a href="https://privefl.github.io/bigsnpr/">bigsnpr</a> and <a href="https://rdatatable.gitlab.io/data.table/">data.table</a>.</p>
<hr />
<div id="obtaining-and-processing-the-1000g-data" class="section level2">
<h2>Obtaining and processing the 1000G data</h2>
<p><em>NB: In this section we discuss how to obtain and process haplotype data from the 1000G project. We have made available the end result, the quality-controlled, European-only data, as a ~270MB download at <a href="https://doi.org/10.5281/zenodo.4705050">https://doi.org/10.5281/zenodo.4705050</a>. If your principal p-values were taken from a GWAS conducted in a European population, you can skip the steps here and use the files in the download instead. You will still have to run LDAK. Note that the data use coordinates from the hg19 genome assembly.</em></p>
<p>We first download the 1000G Phase 3 data in the <code>vcf</code> format. These data use the <code>hg19</code> genome assembly for SNP coordinates.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">for</span> <span class="ex">i</span> in <span class="dt">{1..22}</span><span class="kw">;</span> <span class="kw">do</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>    <span class="fu">wget</span> -O <span class="st">&quot;chr&quot;</span><span class="va">$i</span><span class="st">&quot;.vcf.gz&quot;</span> <span class="st">&quot;ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/ALL.chr&quot;</span><span class="va">$i</span><span class="st">&quot;.phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.vcf.gz&quot;</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">done</span></span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="fu">wget</span> -O <span class="st">&quot;chrX.vcf.gz&quot;</span> <span class="st">&quot;ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/ALL.chrX.phase3_shapeit2_mvncall_integrated_v1b.20130502.genotypes.vcf.gz&quot;</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="fu">wget</span> -O <span class="st">&quot;chrY.vcf.gz&quot;</span> <span class="st">&quot;ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/ALL.chrY.phase3_integrated_v2a.20130502.genotypes.vcf.gz&quot;</span></span></code></pre></div>
<p>Subsequent processing depends on the data being in the PLINK-compatible <code>bed</code>, <code>bim</code>, and <code>fam</code> file formats. We use PLINK to convert the <code>vcf</code> files to these formats.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">for</span> <span class="ex">i</span> in <span class="dt">{1..22}</span><span class="kw">;</span> <span class="kw">do</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>    <span class="ex">plink</span> --vcf <span class="st">&quot;chr&quot;</span><span class="va">$i</span><span class="st">&quot;.vcf.gz&quot;</span> --make-bed --out <span class="st">&quot;chr&quot;</span><span class="va">$i</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="kw">done</span></span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="ex">plink</span> --vcf chrX.vcf.gz --make-bed --out chrX</span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="ex">plink</span> --vcf chrY.vcf.gz --make-bed --out chrY</span></code></pre></div>
<p>The 1000G haplotype data were obtained by sequencing individuals from a variety of populations. In practice, we take a subset of the 1000G samples to ensure that the ancestry of the individuals from which we obtain haplotype data matches the ancestry of the individuals in the GWAS of interest (from which our principal p-values come). Sample ancestry information for the 1000G project can be found at the <a href="https://www.internationalgenome.org/data-portal/sample">data portal</a> of the International Genome Sample Resource.</p>
<p>We specify the desired sample IDs in a <code>fam</code> file. The <code>fam</code> files generated from the <code>vcf</code> files by <code>plink --make-bed</code> should be identical for all chromosomes, so we use a single custom <code>fam</code> file, <code>euro.fam</code>, to downsample all files. <code>euro.fam</code> was obtained by subsetting <code>chr1.fam</code> to retain only those entries with European sample IDs. We write the new files out to the directory <code>euro_only</code>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">for</span> <span class="ex">i</span> in <span class="dt">{1..22}</span><span class="kw">;</span> <span class="kw">do</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>  <span class="ex">plink</span> --bfile <span class="st">&quot;chr&quot;</span><span class="va">$i</span> --keep euro.fam --make-bed --silent --out <span class="st">&quot;euro_only/chr&quot;</span><span class="va">$i</span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="kw">done</span> </span>
<span id="cb3-4"><a href="#cb3-4"></a></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="ex">plink</span> --bfile chrX --keep euro.fam --make-bed --silent --out euro_only/chrX</span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="ex">plink</span> --bfile chrY --keep euro.fam --make-bed --silent --out euro_only/chrY</span></code></pre></div>
<p>The <code>fam</code> files omit sex information. This is problematic only when we wish to carry out QC on the Y chromosome SNPs: PLINK drops heterozygous Y genotypes if we do not affirm the sex of the samples in <code>chrY.fam</code>. We do this by changing the values in the sex code column from 0 (â€˜unknownâ€™) to 1 (â€˜maleâ€™).</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1"></a><span class="fu">sed</span> -i <span class="st">&#39;s/0 0 0 -9/0 0 1 -9/&#39;</span> euro_only/chrY.fam</span></code></pre></div>
<p>We then use a function from the R package <code>bigsnpr</code> to carry out some basic QC on the 1000G data and write out the duly filtered data to another directory, <code>euro_only/qc</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">22</span>) {</span>
<span id="cb5-2"><a href="#cb5-2"></a>       bigsnpr<span class="op">::</span><span class="kw">snp_plinkQC</span>(<span class="dt">plink.path =</span> <span class="st">&#39;/bin/plink&#39;</span>, <span class="dt">prefix.in =</span> <span class="kw">paste0</span>(<span class="st">&#39;euro_only/chr&#39;</span>, i),</span>
<span id="cb5-3"><a href="#cb5-3"></a>                          <span class="dt">prefix.out =</span> <span class="kw">paste0</span>(<span class="st">&#39;euro_only/qc/chr&#39;</span>, i),</span>
<span id="cb5-4"><a href="#cb5-4"></a>                          <span class="dt">geno =</span> <span class="dv">0</span>, <span class="dt">maf =</span> <span class="fl">0.01</span>, <span class="dt">hwe =</span> <span class="fl">1e-10</span>)</span>
<span id="cb5-5"><a href="#cb5-5"></a>}</span>
<span id="cb5-6"><a href="#cb5-6"></a>bigsnpr<span class="op">::</span><span class="kw">snp_plinkQC</span>(<span class="dt">plink.path =</span> <span class="st">&#39;/bin/plink&#39;</span>, <span class="dt">prefix.in =</span> <span class="st">&#39;euro_only/chrX&#39;</span>,</span>
<span id="cb5-7"><a href="#cb5-7"></a>                        <span class="dt">prefix.out =</span> <span class="st">&#39;euro_only/qc/chrX&#39;</span>,</span>
<span id="cb5-8"><a href="#cb5-8"></a>                        <span class="dt">geno =</span> <span class="dv">0</span>, <span class="dt">maf =</span> <span class="fl">0.01</span>, <span class="dt">hwe =</span> <span class="fl">1e-10</span>)</span>
<span id="cb5-9"><a href="#cb5-9"></a></span>
<span id="cb5-10"><a href="#cb5-10"></a>bigsnpr<span class="op">::</span><span class="kw">snp_plinkQC</span>(<span class="dt">plink.path =</span> <span class="st">&#39;/bin/plink&#39;</span>, <span class="dt">prefix.in =</span> <span class="st">&#39;euro_only/chrY&#39;</span>,</span>
<span id="cb5-11"><a href="#cb5-11"></a>                        <span class="dt">prefix.out =</span> <span class="st">&#39;euro_only/qc/chrY&#39;</span>,</span>
<span id="cb5-12"><a href="#cb5-12"></a>                        <span class="dt">geno =</span> <span class="dv">0</span>, <span class="dt">maf =</span> <span class="fl">0.01</span>, <span class="dt">hwe =</span> <span class="fl">1e-10</span>)</span></code></pre></div>
<hr />
</div>
<div id="joining-the-1000g-and-gwas-snps" class="section level2">
<h2>Joining the 1000G and GWAS SNPs</h2>
<p><em>NB: The following processing was carried out with a GWAS containing only autosomal SNPs, so we omit reference to the sex chromosomes henceforth.</em></p>
<p>For the purpose of fitting the KDE in <code>flexible_cfdr</code> we care only about the dependence structure of the SNPs at which our <code>p</code> and <code>q</code> values were obtained, so we filter the 1000G SNPs to retain those for which we have GWAS p-values. Ideally, the 1000G SNPs would form a superset of those in the GWAS, but this is typically not the case; with ~5.5 million SNPs in our GWAS we would expect to lose several tens of thousands of SNPs. The absence of this relatively paltry number of SNPs should have a neglible influence upon the KDE.</p>
<p>To filter the SNPs we use <code>plink --extract</code>, which allows one to extract SNPs based on:</p>
<ol style="list-style-type: decimal">
<li>SNP ID (i.e.Â rsID); or</li>
<li>SNP genomic coordinates</li>
</ol>
<p>rsIDs are not always consistent between data sets and we have found that extracting SNPs using genomic coordinates typically yields a larger intersection of 1000G and GWAS SNPs. Thus we use <code>plink --extract</code> with the <code>--range</code> argument (<a href="http://zzz.bwh.harvard.edu/plink/dataman.shtml#extract">documentation here</a>), which requires that we pass a white space-separated text file specifying a list of genomic â€˜rangesâ€™ (hereafter the â€˜range fileâ€™) in rows in the format <code>chr bp bp ID</code>. In our use case, each SNP corresponds to a range, albeit one of length one: the first and second <code>bp</code> columns which give the start and end coordinates of the range are duplicated. We use rsIDs as range identifiers, but these are essentially superfluous when using the <code>--range</code> argument and will not be used by <code>plink</code> to filter the SNPs.</p>
<p>The coordinates of the GWAS SNPs are usually readily available and a simple approach to generating the requisite range files for <code>plink --extract</code> would copy the genomic coordinates of each SNP to the appropriate chromosome-specific range file (albeit in the <code>plink</code>-compliant <code>chr bp bp rsID</code> format). However, this approach overlooks the possibility that there exist multiple SNPs with different reference/alternative allele pairings at the same locus, that is, duplicates.</p>
<p>We can account for this when preparing the range files by first joining the 1000G SNPs in each chromosomeâ€™s <code>bim</code> file data to our GWAS SNPs and checking that the allele pairings match. This approach also allows us to remove duplicated rows in the range files; as noted above, it is not essential for a good fit that we retain <em>every</em> SNP.</p>
<p>The following exemplifies the sort of R code one can use to write out the range files whilst carrying out the aforementioned checks.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">library</span>(data.table)</span>
<span id="cb6-2"><a href="#cb6-2"></a></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="co"># We assume this contains columns SNPID, CHR19 and BP19 (so-called because of hg19), REF, and ALT</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>gwas_dat &lt;-<span class="st"> </span><span class="kw">fread</span>(<span class="st">&#39;gwas_sum_stats.tsv.gz&#39;</span>, <span class="dt">sep =</span> <span class="st">&#39;</span><span class="ch">\t</span><span class="st">&#39;</span>, <span class="dt">header =</span> T)</span>
<span id="cb6-5"><a href="#cb6-5"></a></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="co"># Iterating over chromosomal bim files</span></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">22</span>) {</span>
<span id="cb6-8"><a href="#cb6-8"></a>  <span class="co"># bim files have no header</span></span>
<span id="cb6-9"><a href="#cb6-9"></a>  bim_dat &lt;-<span class="st"> </span><span class="kw">fread</span>(<span class="kw">sprintf</span>(<span class="st">&#39;euro_only/qc/chr%d.bim&#39;</span>, i), <span class="dt">sep =</span> <span class="st">&#39;</span><span class="ch">\t</span><span class="st">&#39;</span>, <span class="dt">header =</span> F, <span class="dt">col.names =</span> <span class="kw">c</span>(<span class="st">&#39;Chr&#39;</span>, <span class="st">&#39;ID&#39;</span>, <span class="st">&#39;Cm&#39;</span>, <span class="st">&#39;BP19&#39;</span>, <span class="st">&#39;A1&#39;</span>, <span class="st">&#39;A2&#39;</span>) )</span>
<span id="cb6-10"><a href="#cb6-10"></a>  </span>
<span id="cb6-11"><a href="#cb6-11"></a>  bim_join &lt;-<span class="st"> </span><span class="kw">merge</span>(bim_dat, gwas_dat[CHR19 <span class="op">==</span><span class="st"> </span>i], <span class="dt">by.x =</span> <span class="st">&#39;BP19&#39;</span>, <span class="dt">by.y =</span> <span class="st">&#39;BP19&#39;</span>)</span>
<span id="cb6-12"><a href="#cb6-12"></a>  </span>
<span id="cb6-13"><a href="#cb6-13"></a>  <span class="co"># Make sure alleles match, although for two-sided association p-values we don&#39;t care whether ref/alt is reversed</span></span>
<span id="cb6-14"><a href="#cb6-14"></a>  bim_join &lt;-<span class="st"> </span>bim_join[(REF <span class="op">==</span><span class="st"> </span>A1 <span class="op">&amp;</span><span class="st"> </span>ALT <span class="op">==</span><span class="st"> </span>A2) <span class="op">|</span><span class="st"> </span>(REF <span class="op">==</span><span class="st"> </span>A2 <span class="op">&amp;</span><span class="st"> </span>ALT <span class="op">==</span><span class="st"> </span>A1)]</span>
<span id="cb6-15"><a href="#cb6-15"></a>  </span>
<span id="cb6-16"><a href="#cb6-16"></a>  bim_join &lt;-<span class="st"> </span>bim_join[, .(Chr, BP19, BP19, SNPID)]</span>
<span id="cb6-17"><a href="#cb6-17"></a></span>
<span id="cb6-18"><a href="#cb6-18"></a>  <span class="cf">if</span>(<span class="kw">any</span>(<span class="kw">duplicated</span>(bim_join, <span class="dt">by=</span><span class="st">&#39;BP19&#39;</span>))) {</span>
<span id="cb6-19"><a href="#cb6-19"></a>    <span class="kw">warning</span>(<span class="kw">sprintf</span>(<span class="st">&#39;%d duplicates removed from output&#39;</span>, <span class="kw">sum</span>(<span class="kw">duplicated</span>(bim_join, <span class="dt">by =</span> <span class="st">&#39;BP19&#39;</span>))))</span>
<span id="cb6-20"><a href="#cb6-20"></a>  }</span>
<span id="cb6-21"><a href="#cb6-21"></a></span>
<span id="cb6-22"><a href="#cb6-22"></a>  <span class="co"># Remove duplicates</span></span>
<span id="cb6-23"><a href="#cb6-23"></a>  bim_join &lt;-<span class="st"> </span><span class="kw">unique</span>(bim_join, <span class="dt">by=</span><span class="st">&#39;BP19&#39;</span>)</span>
<span id="cb6-24"><a href="#cb6-24"></a></span>
<span id="cb6-25"><a href="#cb6-25"></a>  <span class="kw">fwrite</span>(bim_join, <span class="dt">file =</span> <span class="kw">sprintf</span>(<span class="st">&#39;plinkRanges/chr%d.tsv&#39;</span>, i), <span class="dt">row.names =</span> F, <span class="dt">sep =</span> <span class="st">&#39;</span><span class="ch">\t</span><span class="st">&#39;</span>, <span class="dt">col.names =</span> F, <span class="dt">quote =</span> F)</span>
<span id="cb6-26"><a href="#cb6-26"></a>}</span></code></pre></div>
<p>Note that we took care to use the <code>hg19</code> assembly coordinates to match the assembly used in the 1000G data we downloaded above.</p>
<p>Using these range files we can now filter the 1000G data.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">for</span> <span class="ex">i</span> in <span class="dt">{1..22}</span><span class="kw">;</span> <span class="kw">do</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>  <span class="ex">plink</span> --silent --bfile <span class="st">&quot;euro_only/qc/chr&quot;</span><span class="va">$i</span> --extract <span class="st">&quot;plink_ranges/chr&quot;</span><span class="va">$i</span><span class="st">&quot;.tsv&quot;</span> --range --make-bed --out <span class="st">&quot;filtered/chr&quot;</span><span class="va">$i</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="kw">done</span></span></code></pre></div>
<hr />
</div>
<div id="running-the-ldak-weighting-calculation-procedure" class="section level2">
<h2>Running the LDAK weighting calculation procedure</h2>
<p>The weighting calculation procedure entails a preprocessing step, <code>ldak --cut-weights</code>, and a calculation step, <code>ldak --calc-weights-all</code>. We refer the reader to the <a href="http://dougspeed.com/calculate-weightings/">LDAK documentation</a> for further guidance. An idiosyncracy of our approach is that we process the data in a set of chromosome-specific files. This is an artifact of the format of the 1000G data.</p>
<p>We create the directory <code>ldak</code> and within it subdirectories labelled <code>chrx</code>, where x ranges from 1 to 22, to hold the results of the procedure.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">for</span> <span class="ex">i</span> in <span class="dt">{1..22}</span><span class="kw">;</span> <span class="kw">do</span> </span>
<span id="cb8-2"><a href="#cb8-2"></a>  <span class="ex">ldak</span> --cut-weights <span class="st">&quot;ldak/chr&quot;</span><span class="va">$i</span> --bfile <span class="st">&quot;filtered/chr&quot;</span><span class="va">$i</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>  <span class="ex">ldak</span> --calc-weights-all <span class="st">&quot;ldak/chr&quot;</span><span class="va">$i</span> --bfile <span class="st">&quot;filtered/chr&quot;</span><span class="va">$i</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="kw">done</span></span></code></pre></div>
<p>LDAK will write out the procedureâ€™s results to files named <code>ldak/chrx/weights.all</code>. We join these chromosome-specific files into one.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">for</span> <span class="ex">i</span> in <span class="dt">{1..22}</span><span class="kw">;</span> <span class="kw">do</span></span>
<span id="cb9-2"><a href="#cb9-2"></a> <span class="co"># We omit the header in each file</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>  <span class="fu">sed</span> <span class="st">&quot;s/$/ </span><span class="va">$i</span><span class="st">/&quot;</span> <span class="op">&lt;(</span><span class="fu">tail</span> -n +2 <span class="st">&quot;ldak/chr</span><span class="va">$i</span><span class="st">/weights.all&quot;</span><span class="op">)</span> <span class="op">&gt;&gt;</span> <span class="st">&quot;ldak/combined_weights.all&quot;</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="kw">done</span></span>
<span id="cb9-5"><a href="#cb9-5"></a></span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="co"># We add back in a single header for the combined file</span></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="fu">sed</span> -i <span class="st">&#39;1 i\Predictor Weight Neighbours Tagging Info Check Chr&#39;</span> <span class="st">&quot;ldak/combined_weights.all&quot;</span></span></code></pre></div>
<hr />
</div>
<div id="using-the-ldak-weightings-in-flexible_fcfdr" class="section level2">
<h2>Using the LDAK weightings in <code>flexible_fcfdr</code></h2>
<p>In practice, it is necessary to merge the weightings contained in <code>combined_weights.all</code> back into the file containing the <code>p</code> and <code>q</code> values so that all three vectors can be made available to <code>flexible_cfdr</code>. This poses a problem, however, as the rsIDs in the <code>Predictor</code> column of <code>combined_weights.all</code> are derived from the 1000G <code>bim</code> files, not the GWAS file rsIDs specified in the range files (which are ignored by <code>plink</code> as noted above). Merging 1000G and GWAS SNPs using genomic coordinates is to be preferred over the use of rsIDs as the latter are not always consistent between data sets.</p>
<p><code>combined_weights.all</code> as written out by LDAK does not contain SNP basepair coordinates. This means we must use the <code>bim</code> files contained in the <code>filtered/chrx</code> directories to recover the basepair coordinates and reference/alternative allele pairings. This can be accomplished by matching the SNPs in <code>combined_weights.all</code> to those in the <code>bim</code> files. As the rsIDs in <code>combined_weights.all</code> are derived from these <code>bim</code> files, it is appropriate in this case to merge these data with the use of rsIDs. We provide the following snippets as an example of how this can be accomplished.</p>
<p>To simplify matters, we first concatenate all chromosomal <code>bim</code> files.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">for</span> <span class="ex">i</span> in <span class="dt">{1..22}</span><span class="kw">;</span> <span class="kw">do</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>  <span class="fu">cat</span> <span class="st">&quot;filtered/chr&quot;</span><span class="va">$i</span><span class="st">&quot;.bim&quot;</span> <span class="op">&gt;&gt;</span> <span class="st">&quot;filtered/chr_all.bim&quot;</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="kw">done</span></span></code></pre></div>
<p>We then add the genomic metadata we need to the <code>combined_weights.all</code> LDAK output file.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">library</span>(data.table)</span>
<span id="cb11-2"><a href="#cb11-2"></a></span>
<span id="cb11-3"><a href="#cb11-3"></a>bim_dat &lt;-<span class="st"> </span><span class="kw">fread</span>(<span class="st">&#39;filtered/chr_all.bim&#39;</span>, <span class="dt">sep =</span> <span class="st">&#39;</span><span class="ch">\t</span><span class="st">&#39;</span>, <span class="dt">header =</span> F, <span class="dt">col.names =</span> <span class="kw">c</span>(<span class="st">&#39;Chr&#39;</span>, <span class="st">&#39;ID&#39;</span>, <span class="st">&#39;Cm&#39;</span>, <span class="st">&#39;BP19&#39;</span>, <span class="st">&#39;A1&#39;</span>, <span class="st">&#39;A2&#39;</span>))</span>
<span id="cb11-4"><a href="#cb11-4"></a></span>
<span id="cb11-5"><a href="#cb11-5"></a>weights_dat &lt;-<span class="st"> </span><span class="kw">fread</span>(<span class="st">&#39;ldak/combined_weights.all&#39;</span>, <span class="dt">sep =</span> <span class="st">&#39; &#39;</span>, <span class="dt">header =</span> T)</span>
<span id="cb11-6"><a href="#cb11-6"></a></span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="co"># Drop rows with a missing ID or weight value</span></span>
<span id="cb11-8"><a href="#cb11-8"></a>weights_dat &lt;-<span class="st"> </span><span class="kw">na.omit</span>(weights_dat, <span class="dt">cols =</span> <span class="kw">c</span>(<span class="st">&#39;Predictor&#39;</span>, <span class="st">&#39;Weight&#39;</span>))</span>
<span id="cb11-9"><a href="#cb11-9"></a></span>
<span id="cb11-10"><a href="#cb11-10"></a>join_dat &lt;-<span class="st"> </span><span class="kw">merge</span>(weights_dat, bim_dat[. , (ID, Chr, BP19, A1, A2)], <span class="dt">all.x =</span> T, <span class="dt">by.x =</span> <span class="kw">c</span>(<span class="st">&#39;Predictor&#39;</span>, <span class="st">&#39;Chr&#39;</span>), <span class="dt">by.y =</span> <span class="kw">c</span>(<span class="st">&#39;ID&#39;</span>, <span class="st">&#39;Chr&#39;</span>), <span class="dt">sort =</span> F)</span>
<span id="cb11-11"><a href="#cb11-11"></a></span>
<span id="cb11-12"><a href="#cb11-12"></a><span class="kw">fwrite</span>(join_dat, <span class="dt">file =</span> <span class="st">&#39;ldak/combined_weights_meta.all&#39;</span>, <span class="dt">sep =</span> <span class="st">&#39; &#39;</span>, <span class="dt">col.names =</span> T, <span class="dt">row.names =</span> F, <span class="dt">quote =</span> F)</span></code></pre></div>
<p>The format of the file in which your <code>p</code> and <code>q</code> are stored will of course vary, but the snippet below illustrates how <code>combined_weights_meta.all</code> can be merged with it.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a>weights_dat &lt;-<span class="st"> </span><span class="kw">fread</span>(<span class="st">&#39;ldak/combined_weights_meta.all&#39;</span>, <span class="dt">sep =</span> <span class="st">&#39; &#39;</span>, <span class="dt">header =</span> T, <span class="dt">select =</span> <span class="kw">c</span>(<span class="st">&#39;Predictor&#39;</span>, <span class="st">&#39;Weight&#39;</span>, <span class="st">&#39;Chr&#39;</span>, <span class="st">&#39;BP19&#39;</span>, <span class="st">&#39;A1&#39;</span>, <span class="st">&#39;A2&#39;</span>))</span>
<span id="cb12-2"><a href="#cb12-2"></a></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="co"># We assume this contains columns SNPID, CHR19 and BP19 (so-called because of hg19), REF, and ALT</span></span>
<span id="cb12-4"><a href="#cb12-4"></a>gwas_dat &lt;-<span class="st"> </span><span class="kw">fread</span>(<span class="st">&#39;gwas_sum_stats.tsv.gz&#39;</span>, <span class="dt">sep =</span> <span class="st">&#39;</span><span class="ch">\t</span><span class="st">&#39;</span>, <span class="dt">header =</span> T)</span>
<span id="cb12-5"><a href="#cb12-5"></a></span>
<span id="cb12-6"><a href="#cb12-6"></a>gwas_dat &lt;-<span class="st"> </span><span class="kw">merge</span>(gwas_dat, weights_dat, <span class="dt">by.x =</span> <span class="kw">c</span>(<span class="st">&#39;CHR19&#39;</span>, <span class="st">&#39;BP19&#39;</span>), <span class="dt">by.y =</span> <span class="kw">c</span>(<span class="st">&#39;Chr&#39;</span>, <span class="st">&#39;BP19&#39;</span>), <span class="dt">sort =</span> F)</span>
<span id="cb12-7"><a href="#cb12-7"></a></span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="co"># Drop rows where the ref/alt allele pairing differs from that already present</span></span>
<span id="cb12-9"><a href="#cb12-9"></a>gwas_dat &lt;-<span class="st"> </span>gwas_dat[((REF <span class="op">==</span><span class="st"> </span>A1 <span class="op">&amp;</span><span class="st"> </span>ALT <span class="op">==</span><span class="st"> </span>A2) <span class="op">|</span><span class="st"> </span>(REF <span class="op">==</span><span class="st"> </span>A2 <span class="op">&amp;</span><span class="st"> </span>ALT <span class="op">==</span><span class="st"> </span>A1))]</span>
<span id="cb12-10"><a href="#cb12-10"></a></span>
<span id="cb12-11"><a href="#cb12-11"></a><span class="co"># Drop now-redundant allele columns</span></span>
<span id="cb12-12"><a href="#cb12-12"></a>gwas_dat[, <span class="kw">c</span>(<span class="st">&#39;A1&#39;</span>, <span class="st">&#39;A2&#39;</span>) <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="ot">NULL</span> ]</span></code></pre></div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
